"""
Bash script generator - core logic for generating server setup scripts.
Handles module dependencies, user creation, and idempotent operations.
"""
import re
from typing import List, Dict, Set
from models import User, Module


class ScriptGenerator:
    """Main script generator class"""

    INPUTRC_CONTENT = """$include /etc/inputrc
"\\e[A":history-search-backward
"\\e[B":history-search-forward"""

    def __init__(self):
        """Initialize generator"""
        self.script_parts = []

    def generate(
        self,
        users: List[User],
        modules: List[Module],
        module_inputs: Dict[int, str],
        hostname: str = '',
        timezone: str = 'UTC'
    ) -> str:
        """
        Generate complete bash script.

        Args:
            users: List of User objects to create
            modules: List of Module objects to execute
            module_inputs: Dict mapping module_id to user input values
            hostname: System hostname (optional)
            timezone: System timezone

        Returns:
            Complete bash script as string
        """
        self.script_parts = []

        # Add header
        self._add_header()

        # Add prerequisite checks
        self._add_prerequisites()

        # Sort modules by priority and resolve dependencies
        sorted_modules = self._sort_modules_by_dependencies(modules)

        # Generate user creation section
        if users:
            self._add_users_section(users)

        # Generate modules execution
        self._add_modules_section(sorted_modules, module_inputs, users)

        # Add footer
        self._add_footer()

        return '\n'.join(self.script_parts)

    def _add_header(self):
        """Add script header with safety checks"""
        header = """#!/bin/bash
################################################################################
# Linux Server Setup Script
# Generated by Server Setup Generator
# This script is idempotent and can be run multiple times safely
################################################################################

set -euo pipefail  # Exit on error, undefined vars, pipe failures
IFS=$'\\n\\t'       # Safer field separator

# Color output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root
if [[ $EUID -ne 0 ]]; then
   log_error "This script must be run as root"
   exit 1
fi

log_info "Starting server setup..."
START_TIME=$(date +%s)
"""
        self.script_parts.append(header)

    def _add_prerequisites(self):
        """Add prerequisite checks"""
        prereq = """
################################################################################
# Prerequisites
################################################################################

# Detect OS
if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS=$ID
    OS_VERSION=$VERSION_ID
else
    log_error "Cannot detect OS"
    exit 1
fi

log_info "Detected OS: $OS $OS_VERSION"

# Update package cache
log_info "Updating package cache..."
if [[ "$OS" == "ubuntu" ]] || [[ "$OS" == "debian" ]]; then
    apt-get update -qq
elif [[ "$OS" == "centos" ]] || [[ "$OS" == "rhel" ]] || [[ "$OS" == "fedora" ]]; then
    yum check-update -q || true
else
    log_warn "Unknown OS, skipping package cache update"
fi
"""
        self.script_parts.append(prereq)

    def _add_users_section(self, users: List[User]):
        """Generate user creation section"""
        section = """
################################################################################
# User Management
################################################################################

log_info "Creating users..."
"""
        self.script_parts.append(section)

        for user in users:
            self._add_user_creation(user)

    def _add_user_creation(self, user: User):
        """Add user creation code"""
        username = self._sanitize_username(user.username)
        groups_list = user.groups_list
        ssh_keys_list = user.ssh_keys_list

        user_code = f"""
# Create user: {username}
if id "{username}" &>/dev/null; then
    log_info "User {username} already exists, updating..."
else
    log_info "Creating user {username}..."
    useradd -m -s /bin/bash "{username}"
fi
"""

        # Add to groups
        if groups_list:
            groups_str = ','.join(groups_list)
            user_code += f"""
# Add {username} to groups: {groups_str}
usermod -aG {groups_str} "{username}"
"""

        # Setup SSH keys
        if ssh_keys_list:
            user_code += f"""
# Setup SSH keys for {username}
mkdir -p /home/{username}/.ssh
chmod 700 /home/{username}/.ssh
cat > /home/{username}/.ssh/authorized_keys <<'SSH_KEYS_EOF'
"""
            for key in ssh_keys_list:
                user_code += f"{key}\n"

            user_code += f"""SSH_KEYS_EOF
chmod 600 /home/{username}/.ssh/authorized_keys
chown -R {username}:{username} /home/{username}/.ssh
"""

        # Add .inputrc
        user_code += f"""
# Create .inputrc for {username}
cat > /home/{username}/.inputrc <<'INPUTRC_EOF'
{self.INPUTRC_CONTENT}
INPUTRC_EOF
chown {username}:{username} /home/{username}/.inputrc
chmod 644 /home/{username}/.inputrc
"""

        self.script_parts.append(user_code)

    def _add_modules_section(
        self,
        modules: List[Module],
        module_inputs: Dict[int, str],
        users: List[User]
    ):
        """Generate modules execution section"""
        if not modules:
            return

        section = """
################################################################################
# Modules Execution
################################################################################
"""
        self.script_parts.append(section)

        for module in modules:
            self._add_module_execution(module, module_inputs, users)

    def _add_module_execution(
        self,
        module: Module,
        module_inputs: Dict[int, str],
        users: List[User]
    ):
        """Add module execution code"""
        module_code = f"""
log_info "Executing module: {module.name}"
# {module.description}
"""

        # Get bash code and replace input placeholder if needed
        bash_code = module.bash_code

        # Replace {input} placeholder with actual value
        if module.requires_input:
            input_value = module_inputs.get(module.id, module.input_default)
            bash_code = bash_code.replace('{input}', input_value)

        # Special handling for Docker module - add users to docker group
        if 'docker' in module.name.lower() and 'install' in module.name.lower():
            bash_code += '\n\n# Add users to docker group\n'
            for user in users:
                if 'docker' in user.groups_list:
                    username = self._sanitize_username(user.username)
                    bash_code += f'usermod -aG docker "{username}"\n'

        module_code += bash_code + '\n'
        self.script_parts.append(module_code)

    def _add_footer(self):
        """Add script footer"""
        footer = """
################################################################################
# Completion
################################################################################

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

log_info "Server setup completed successfully!"
log_info "Total time: ${DURATION}s"

echo ""
echo "========================================="
echo "Setup Summary:"
echo "========================================="
echo "Script completed at: $(date)"
echo "Duration: ${DURATION}s"
echo ""
echo "Please review the changes and reboot if necessary."
echo "========================================="
"""
        self.script_parts.append(footer)

    def _sort_modules_by_dependencies(self, modules: List[Module]) -> List[Module]:
        """
        Sort modules by priority and resolve dependencies.
        Uses topological sort to ensure dependencies are executed first.

        Args:
            modules: List of Module objects

        Returns:
            Sorted list of modules
        """
        # Build dependency graph
        module_map = {m.name: m for m in modules}
        visited = set()
        temp_visited = set()
        sorted_modules = []

        def visit(module: Module):
            """DFS visit for topological sort"""
            if module.name in temp_visited:
                # Circular dependency detected, ignore
                return
            if module.name in visited:
                return

            temp_visited.add(module.name)

            # Visit dependencies first
            for dep_name in module.dependencies_list:
                if dep_name in module_map:
                    visit(module_map[dep_name])

            temp_visited.remove(module.name)
            visited.add(module.name)
            sorted_modules.append(module)

        # Visit all modules
        for module in modules:
            if module.name not in visited:
                visit(module)

        # Sort by priority for modules at the same dependency level
        sorted_modules.sort(key=lambda m: m.priority)

        return sorted_modules

    def _sanitize_username(self, username: str) -> str:
        """
        Sanitize username to ensure it's safe for bash.

        Args:
            username: Raw username

        Returns:
            Sanitized username
        """
        # Remove any characters that aren't alphanumeric, underscore, or dash
        sanitized = re.sub(r'[^a-zA-Z0-9_-]', '', username)
        # Ensure it starts with a letter or underscore
        if sanitized and not sanitized[0].isalpha() and sanitized[0] != '_':
            sanitized = '_' + sanitized
        return sanitized[:32]  # Limit to 32 characters

    @staticmethod
    def validate_ssh_key(key: str) -> bool:
        """
        Validate SSH public key format.

        Args:
            key: SSH public key string

        Returns:
            True if valid, False otherwise
        """
        key = key.strip()
        if not key:
            return False

        # Check for common SSH key formats
        valid_prefixes = ['ssh-rsa', 'ssh-dss', 'ssh-ed25519', 'ecdsa-sha2-']

        for prefix in valid_prefixes:
            if key.startswith(prefix):
                parts = key.split()
                # Valid key should have at least 2 parts: type and key
                return len(parts) >= 2

        return False

    @staticmethod
    def validate_username(username: str) -> bool:
        """
        Validate username format.

        Args:
            username: Username string

        Returns:
            True if valid, False otherwise
        """
        if not username:
            return False

        # Username should be 1-32 characters
        if len(username) > 32:
            return False

        # Should contain only alphanumeric, underscore, or dash
        if not re.match(r'^[a-zA-Z0-9_-]+$', username):
            return False

        # Should start with letter or underscore
        if not username[0].isalpha() and username[0] != '_':
            return False

        return True
